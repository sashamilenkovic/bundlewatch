{"_path":"/architecture","_dir":"","_draft":false,"_partial":false,"_locale":"","title":"Architecture","description":"Understand how parsers, plugins, storage, and dashboards fit together.","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"Ô∏è-architecture"},"children":[{"type":"text","value":"üèóÔ∏è Architecture"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"BundleWatch is a pnpm monorepo with small, composable packages. Everything shares the same "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BuildMetrics"}]},{"type":"text","value":" type from "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"packages/core"}]},{"type":"text","value":", so plugins and the CLI can swap data freely."}]},{"type":"element","tag":"h2","props":{"id":"package-graph"},"children":[{"type":"text","value":"Package graph"}]},{"type":"element","tag":"pre","props":{"code":"@milencode/bundlewatch-core (types + collectors + comparison + git storage)\n        ‚Üì\n        ‚îú‚îÄ @milencode/bundlewatch-parsers    # ingest bundler outputs\n        ‚îú‚îÄ @milencode/bundlewatch-vite-plugin\n        ‚îú‚îÄ @milencode/bundlewatch-webpack-plugin\n        ‚îú‚îÄ @milencode/bundlewatch-next-plugin\n        ‚îú‚îÄ @milencode/bundlewatch-cli\n        ‚îî‚îÄ @milencode/bundlewatch-dashboard (HTML output helpers)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@milencode/bundlewatch-core (types + collectors + comparison + git storage)\n        ‚Üì\n        ‚îú‚îÄ @milencode/bundlewatch-parsers    # ingest bundler outputs\n        ‚îú‚îÄ @milencode/bundlewatch-vite-plugin\n        ‚îú‚îÄ @milencode/bundlewatch-webpack-plugin\n        ‚îú‚îÄ @milencode/bundlewatch-next-plugin\n        ‚îú‚îÄ @milencode/bundlewatch-cli\n        ‚îî‚îÄ @milencode/bundlewatch-dashboard (HTML output helpers)\n"}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Core"}]},{"type":"text","value":" exposes "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"collectMetrics"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"compareMetrics"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GitStorage"}]},{"type":"text","value":", and "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ReportGenerator"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Parsers"}]},{"type":"text","value":" convert native bundler stats (Webpack stats, Vite/Rollup bundles) to "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"BuildMetrics"}]},{"type":"text","value":" and also generate enhanced dashboards."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Plugins / CLI"}]},{"type":"text","value":" decide "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"when"}]},{"type":"text","value":" to collect metrics (after a build, after "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"vite build"}]},{"type":"text","value":", etc.) and how to persist them."}]}]},{"type":"element","tag":"h2","props":{"id":"parser-pivot"},"children":[{"type":"text","value":"Parser pivot"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Originally every plugin walked the output directory, recompressed assets, and guesstimated dependency graphs. The parser packages now tap into the bundler‚Äôs own metadata so the work happens in-memory:"}]},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"Approach"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"What Happens"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"Time"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Legacy collector"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Read every file ‚Üí gzip ‚Üí brotli ‚Üí stitch metrics"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"~2 s"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Parser (current goal)"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Consume stats/bundle JSON in memory ‚Üí map to metrics"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"~50 ms"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The Webpack plugin already uses "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"parseWebpackStats"}]},{"type":"text","value":". The Vite plugin still relies on "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"MetricsCollector"}]},{"type":"text","value":" and will switch once "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"parseViteBundle"}]},{"type":"text","value":" lands."}]},{"type":"element","tag":"h2","props":{"id":"git-storage-layer"},"children":[{"type":"text","value":"Git storage layer"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"GitStorage"}]},{"type":"text","value":" writes metrics to an orphan branch (default "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"bundlewatch-data"}]},{"type":"text","value":"). Each branch gets its own folder:"}]},{"type":"element","tag":"pre","props":{"code":"data/\n  main/\n    1730939472000-abc1234.json\n    latest.json\n  feature/parser-refactor/\n    1731021234000-def5678.json\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"data/\n  main/\n    1730939472000-abc1234.json\n    latest.json\n  feature/parser-refactor/\n    1731021234000-def5678.json\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"During CI the plugin/CLI saves the current metrics and optionally compares against another branch before logging a report or failing budgets."}]},{"type":"element","tag":"h2","props":{"id":"dashboards-insights"},"children":[{"type":"text","value":"Dashboards & insights"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"packages/parsers/src/dashboard.ts"}]},{"type":"text","value":" builds a treemap from either detailed dependency metrics or the bundle list."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Webpack plugin ships an ‚Äúenhanced dashboard‚Äù (modules, dependencies, source-file stats) because the parser returns all that info."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Vite/Next/CLI still render a simpler treemap until they switch to parser-derived data."}]}]},{"type":"element","tag":"h2","props":{"id":"roadmap-snapshot"},"children":[{"type":"text","value":"Roadmap snapshot"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Vite parser integration"}]},{"type":"text","value":" ‚Äì wire "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"createAnalyzerState"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"collectModuleInfo"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"analyzeBundle"}]},{"type":"text","value":" into the Vite plugin‚Äôs "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"generateBundle"}]},{"type":"text","value":" hook."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"CLI / Next"}]},{"type":"text","value":" ‚Äì let these consume parser outputs or accept pre-generated stats."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Docs"}]},{"type":"text","value":" ‚Äì keep this site in sync with code changes by updating Markdown alongside Pull Requests."}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"package-graph","depth":2,"text":"Package graph"},{"id":"parser-pivot","depth":2,"text":"Parser pivot"},{"id":"git-storage-layer","depth":2,"text":"Git storage layer"},{"id":"dashboards-insights","depth":2,"text":"Dashboards & insights"},{"id":"roadmap-snapshot","depth":2,"text":"Roadmap snapshot"}]}},"_type":"markdown","_id":"content:architecture.md","_source":"content","_file":"architecture.md","_stem":"architecture","_extension":"md"}